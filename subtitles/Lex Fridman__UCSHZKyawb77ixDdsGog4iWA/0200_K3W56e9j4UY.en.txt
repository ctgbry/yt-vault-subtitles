[00:01]
and what was the first programming
language if I may ask it this way that
you fell in love with hi I think I'll
call 60 and after that I remember my arm
the snowboard
I remember Fortran didn't fall in love
with that I remember Pascal didn't fall
in love with that it already got in the
way of me and then I just covered a
simpler and that was much more fun and
from there I went to micro micro code so
you were drawn to the he found the low
level stuff beautiful I went through a
lot of languages and then I spent
significant time in in a simpler and
micro code that was sort of the first
really profitable things I paid for my
masters actually and then I discovered
Simula which was absolutely great Simula

[01:03]
Simula which was absolutely great Simula
simulated
Albert 60 done primarily for simulation
but basically they invented object
oriented programming at inheritance and
runtime polymorphism when they were
while they were doing it and that was
the language that taught me that you
could have the sort of the problems of a
program grow with size of the program
Berlin with the square of the size of
the program that is you can actually
module arise very nicely and that that
that was a surprise to me it was also a
surprise to me that a stricter type
system than Pascal's was helpful whereas
Pascal's type system got in my way all
the time so you need a strong type
system to organize your code well but it

[02:02]
system to organize your code well but it
has to be extensible and flexible let's
get into the details a little bit what
kind of if you remember what kind of
type system to Pascal have what type
system typing system did Algol 60 have
basically Pascal was sort of the
simplest language that Niklaus Viet
could define that served the needs of
Nicolas Viet at the time and it has a
sort of a highly moral tone to it that
is if you can say it in Pascal it's good
and if you can't it's not so good
whereas
Simula larger is basically to build your
own type system so instead of trying to
fit yourself into Niklaus pierce'sworld
Christ knew God's language and early on
Dallas language allowed you to build
your own so it's sort of close to the

[03:01]
your own so it's sort of close to the
original idea of you you you build a
domain-specific language as a matter of
fact what you build is a set of types
and relations among types that allows
you to express something that suitable
for an application
so when you say types the stuff you're
saying has echoes of object-oriented
programming Dettol they invented it
every language that uses the word class
for type is a descendant of Simula
directly or indirectly Christ knew go on
all you and Al were mathematicians and
they didn't think in terms of types they
but they understood sets and classes of
elements and so they caught that typed
classes and basically in C++ as in
similar classes are user defined type so

[04:01]
similar classes are user defined type so
can you try the impossible task and give
a brief history of programming languages
from your perspective so we started with
Algol 60 Simula Pascal but that's just
the 60s and seven I can try
the most sort of interesting and major
improvement of programming languages was
Fortran the first Fortran because before
that all code was written for a specific
machine and each specific machine had a
language a simply language or cross
emplo or some extension of that idea but
it you are writing for specific machine
in the term in the language of that
machine and
Marcus and his team at IBM built a
language that would allow you to to
write what you really wanted that is you

[05:03]
write what you really wanted that is you
can write it in a language that was
natural for people now these people
happen to be engineers and physicists so
the language I came out was somewhat
unusual for the rest of the world but
basically they said formula translation
because they wanted to have the
mathematical formulas translated into
the machine and as a side effect
they got portability because now they
are writing in the terms that the humans
used and the way humans thought and then
they had a program that translated it
into the machines needs and that was new
and that was great and it's something to
remember we want to raise the language
to the human level but we don't want to
lose the efficiency so and the less
first step towards the human that was
the first step and of course they were
very particular kind of humans business

[06:01]
very particular kind of humans business
people but there's a difference so they
got COBOL instead and etc etc and
simular came out no let's not go to
simulate yet let's go to Al Gore Fortran
didn't have at the time the notions of
not a precise notion of type not a
precise notion of scope not a set of
translation phases that was what we have
today
lexical syntax semantics it was sort of
a bit of a model in the early days but
hey they're just done the biggest
breakthrough in history of programming
right so you can't criticize them for
not having gotten all the technical
details right so we got alcohol that was
very pretty and most people in Commerce
and science considered it useless
because it was not flexible enough and

[07:00]
because it was not flexible enough and
it wasn't efficient enough and etcetera
etcetera
but that was the breakthrough from the
technical point of view then similar
came along to make that idea more
flexible and you could define your own
types and that's where where I got very
interested first Nicole was the main
idea man behind Simula I was late 60s
this was late 60s was a visiting
professor in halls and so I learned
object-oriented programming by sitting
around and well in theory discussing
with with Christ new goal but Christ and
once you get started and in full flow
it's very hard to get a word in edgeways
where you're just listed so it was great
I learned it from them not to
romanticize the notion but it seems like

[08:00]
romanticize the notion but it seems like
a big leap to think about
object-oriented programming it's really
a leap of abstraction it's yes and was
that as big and beautiful of a leap as
it seems from now in retrospect I was in
an obvious one at the time it was not
obvious and many people have tried to do
something like that and most people
didn't come up with something as
wonderful as similar lots of people got
their PhDs and made their careers out of
forgetting about Simula or never knowing
it for me the key idea was basically I
could get my own types and that's the
idea that goes for a lines of C++ where
I can get better types and more flexible
types and more efficient types but it's
still the fundamental idea when I want
to write a program I want to write it

[09:00]
to write a program I want to write it
with my types that is appropriate to my
problem and under the constraints that
I'm under with hardware software
environment etc and that's that's the
key idea people picked up on the
higher is in the virtual functions and
the inheritance and that was only part
of it it was an interesting in major
part and still a major part and a lot of
graphic stuff but it was not the most
fundamental it it was when you wanted to
relate one type to another you don't
want the more to be independent that the
classical example is that you don't
actually want to write city simulation
with vehicles
where you say well if it's a buy signal
to write the code for turning a bicycle
to the left if it's a normal car turn

[10:01]
to the left if it's a normal car turn
right a normal car way if it's a fire
engine and right the fire and in waited
out a doubt about you get these big case
statements and bunches of if statement
and such instead you tell the other the
base class that that's the Viacom saying
turn turn left the way you want to and
this is actually a real example they
they used it to simulate and optimize
the emergency the the emergency services
for somewhere Norway back in the 60s Wow
so this was one of the early examples
for why you needed inheritance and and
you needed runtime polymorphism because
you wanted to handle this set of
vehicles in a manageable way you you you
can't just rewrite your code each time a
new kind of vehicle comes along yeah

[11:03]
new kind of vehicle comes along yeah
that's a beautiful powerful idea and of
course it it stretches through your work
Lucy bus bosses will talk about but I
think you structured nicely what other
breakthroughs came along in the history
of programming language is it if we were
to tell the history in that way
obviously I'm bitter telling the part of
the history that the surpassed I am one
as opposed to or in the past
yeah you skip the hippy
John McCarthy and Lisp one of my
favorite languages but let's understand
what Lisp is not one of my favorite
language yes it's obviously important
it's obviously interesting lots of
people write code in it and then they
rewrite it into C or C++ when they want
to go to production yes it's in the
world
I met which are constrained by
performance reliability issues

[12:01]
performance reliability issues
deployability cost of hardware I I don't
like things to be too dynamic it is
really hard to write a piece of code
that's perfectly flexible that you can
also deploy on a small computer and that
you can also put in say a telephone
switch in Bogota what's the chance if
you get an error and you find yourself
in the debugger that the telephone
switch in pockets are on late Sunday
night has a programmer around right the
chance is zero and so a lot of things I
think most about can't afford that
flexibility I'm quite aware that maybe
70 80 % of all code are not under the
kind of constraints I'm interested in
but somebody has to do the job I'm doing
because you have to get from these high

[13:02]
because you have to get from these high
level flexible languages to the hardware
the stuff that lasts for 10 20 30 years
is robust
yeah operates under very constrained
conditions yes absolutely that's right
and it's fascinating and beautiful in
its own way it's C++ is one of my
favorite languages and so is Lisp so I
can I can embody two for different
reasons as as a programmer I understand
why it is popular and I can see the
beauty of the ideas and similarly with
this more talk
it's just now this relative thank it is
not
as relevant in my world and by the way I
distinguish between those my functional
languages where I go to things like ml
and Haskell
different different kind of languages
they have a different kind of beauty in

[14:01]
they have a different kind of beauty in
there very interesting and I actually
try to learn from all the languages I
encounter to see what is there that
would make working on the kind of
problems I'm interested in with the kind
of constraints that that I'm interested
in what can actually be done better
because we can surely do better than we
do today
you