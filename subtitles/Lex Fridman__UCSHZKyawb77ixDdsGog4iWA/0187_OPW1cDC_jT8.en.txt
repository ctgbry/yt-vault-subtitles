[00:01]
and then there's this idea of concepts
that puts some now I've never even the I
don't know if it was ever available in
any form but it puts some constraints on
the stuff you can parameterize
essentially let me try and explain yes
so yes it wasn't there ten years ago we
have had versions of it that actually
work for the last four or five years it
was a design by Gabby does raise true
certain and me we were professors and
postdocs in Texas at the time and the
implementation by Andres Arden has been
available for at that time and it is
part of C++ 20 and the standard library

[01:01]
part of C++ 20 and the standard library
that uses it so this is becoming really
very real it's available in clang in GCC
GCC for a couple of years and I believe
Microsoft assume assume going to do it
expect a wall of C++ 20 to be available
so in all the major compilers in 20 but
this kind of stuff is it's available now
I'm just saying that because otherwise
people might think I was talking about
science fiction and so what I'm going to
say Israel on Crete you can write it
today
and there's production users of it so
the basic idea is that when you have a a
generic component like a sort function
the sort function will require at least
two parameters one a data structure with
a given type and comparison criteria and

[02:03]
a given type and comparison criteria and
these things are related but obviously
you can't compare things if you don't
know what the type of things you compare
and so you want to be able to say I'm
going to sort something and did this so
be sortable what does it mean to be
sortable you look it up in the standard
it has to have it has to be a sequence
with a beginner and an end there has to
be random access to that sequence and
there has to be the element types has to
be comparable like a more like operator
can I do it yes what illogical already
cannot basically what concepts are there
compile-time predicates there predicates
you can ask are you a sequence yes I
have begin an end
are you a random exit sequence yes I
have subscripting and plus it's your

[03:01]
have subscripting and plus it's your
element type something that has a less
then yes
I have a less than hits and so basically
that's the system and so instead of
saying I will take a parameter of any
type it'll say I'll take something
that's horrible and it's well defined
and so we say okay you can sorta less
than I don't want less then I want
greater than us or something I invent so
you have two parameters the sortable
thing and the compassion criteria and
the comparison criteria will say well I
can you you can write it saying it
should operate on the element type and
it has the compassion operations so
that's the simply the fundamental thing
it's compile-time predicates do you have
the properties I need so it specifies
the requirements of the code on the
parameters that gets yes there are lots

[04:00]
parameters that gets yes there are lots
of types actually but operating in the
space of concepts concepts the word
concept was used by Alec Stephan of who
is sort of the father of generic
programming in the context of C++
there's other places that use that word
but the way we call Genetic Programming
is Alex's and he called them concepts
because he said there they are the sort
of the fundamental concepts of an area
so they should be called concepts and
we've had concepts all the time if you
look at the K&R book about si si has
arithmetic types and it has integral
types it says so in the book and then it
lists what they are and they have
certain properties the difference to me
is that we can actually write a concept
that will ask a type are you an integral
type do you have the properties

[05:02]
type do you have the properties
necessary to be an integral type do you
have cross - divide so what may be the
story of concepts because I thought it
might be part of C++ 11 C C C's o X or
whatever it was at the time what was the
why didn't it what like what we'll talk
a little bit about this fascinating
process of standards because I think
it's really interesting for people it's
interesting for me but why did it take
so long what shapes that the idea of
concepts take what were the challenges
back in 87 or there abouts 1987 well
1987 like they are about so when I was
designing templates obviously I wanted
to express the notion of what is
required by a template of its arguments
and so I looked at this and basically

[06:03]
and so I looked at this and basically
for for templates I wanted three
properties I wanted to be very flexible
it had to be able to express things I
couldn't imagine because I know I can't
imagine everything and I've been
suffering from languages and try to
constrain you to only do what you're the
designer thought good didn't want to do
that secondly it had to run faster
as fast or faster that hand-written code
so basically if I have a vector of T and
I take a vector of cha it should run as
fast as you build a vector of cha
yourself without parameterization and
second and thirdly I wanted to be able
to express the constraints of of the
arguments have proper type checking of
the interfaces and neither I nor anybody

[07:02]
the interfaces and neither I nor anybody
else at the time knew how to get all
three and I thought for C++ I must have
the two first otherwise it's not C++ and
it bothered me for an hour a couple of
decades that I couldn't solve the third
one I mean I was the one that put
function argument type checking in to
see I know the value of good interfaces
I didn't invent that idea it's very
common but I did it and I wanted to do
the same for templates of course and I
could so it bothered me then we try it
again mm of to 2003
cavitus raised and I started analyzing
the problem explained possible solutions
it was not a complete design a group in
University of Indiana an old friend of
mine they started a project at Indiana

[08:03]
mine they started a project at Indiana
and we thought we could get a good
system of concepts in another two or
three years that would have made C++ la
11 to C++ Oh 607 well it turns out that
I think we got a lot of the fundamental
ideas are wrong they were took on
conventional they didn't quite fit C++
in my opinion didn't serve implicit
conversions very well it didn't
of mixed mixed type arithmetic Mitch
type computation computations very well
a lot of stuff came out of the
functional
community and it that community didn't

[09:00]
community and it that community didn't
deal with multiple types in in the same
way as C++ does had more constraints on
on what you could express and didn't
have the draconian performance
requirements and basically we tried we
tried very hard we had some successes
but it just in the end wasn't didn't
compile fast enough was too hard to use
and didn't run fast enough unless you
had optimizes that was beyond the state
of the art they still are so we had to
do something else basically it was the
idea that a set of parameters has
defines a set of operations and you go
through an indirection table just like
for virtual functions then you try to
optimize the interaction away to get

[10:00]
optimize the interaction away to get
performance and we just couldn't do all
of that
you