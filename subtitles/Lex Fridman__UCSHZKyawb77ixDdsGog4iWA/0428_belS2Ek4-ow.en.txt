[00:00]
this is a list comprehension that allows
you to define one list in terms of
another list
and is reminiscent of set notation from
mathematics
the elegance simplicity and power of
this notation
makes it in my opinion the best feature
of python
now what does it mean to be a best
feature of a programming language
to me it's a feature that makes you fall
in love with the language
and the feature that makes you enjoy
programming in the language for many
years
so the basic notation is a for loop over
some input list nums and a function like
f of x that computes something
for each element x in nums in addition
there's a
filter conditional like if g of x
some function some expression that
filters the elements of nums
and only keeps the ones that pass this
conditional
let's look at an example input list nums
one two three
four the list comprehension squares each
element of nums
so x times x for x in nums and so that

[01:01]
so x times x for x in nums and so that
creates a list that contains 1 4
9 and 16. simple beautiful
and now to add a filter to keep just the
even numbers we can add into the
filter conditional the list
comprehension x modulo two equals zero
and then the result is the squaring of
the elements that pass the filter
which is four and sixteen now some would
argue that you can achieve the same kind
of results with for loops
or more direct comparison is the map and
filter functions which are
also available in python so what would
that look like
to square each element in the list you
could have a lambda function that does
the squaring and a map
that applies that lambda function to
each element of nums
that's the second line the code here and
the third line
you can add a filter to that so first
apply
a filter with a lambda function that
does the module two equals zero
conditional and then on top of that on
the elements that pass the filter you
again do the map function of the lambda

[02:01]
again do the map function of the lambda
that squares each element now i believe
this is also
beautiful and powerful notation but to
me it's not
nearly as elegant pythonic and readable
as the list comprehension notation
i already did a video on the most
controversial
python feature which in my opinion is
the wallers operator
it comes into play nicely with list
comprehensions now if we take some
difficult to compute function like
fibo here which computes the nth element
of the fibonacci sequence
the one line ternary operator
implementation of the function
written by me untested i'll leave it to
you as homework to test if this actually
works
and i threw it in there to give a shout
out to two other things i enjoy
which is recursion and the ternary
operator
the if else notation of which in python
i think is another beautiful design
choice
that makes an otherwise cryptic looking

[03:00]
that makes an otherwise cryptic looking
ternary operator
actually readable to our human brains
and so if we take then
another definition of numbs that goes
from one to six
we can create a basic list comprehension
that applies the fibo function to each
element of nums
resulting in the familiar fibonacci
sequence of one one two three five eight
now if we wanted to also add a
conditional which is where the walrus
operator comes in
we can compute fibo x and assign it
to the variable y via the walrus
operator's assignment expression
and then do the modules 2 equals 0 check
to keep
just the even elements of the fibonacci
sequence and then in the actual output
of the list comprehension we can just
use the variable y
as opposed to recomputing the fable
function so the result of this list
comprehension that uses the wallace
operator
is 2 and 8. so list comprehension
actually creates a list objects computes
all the elements in the list and stores
the entire list of memory
while the generator expression stores

[04:00]
while the generator expression stores
just the iterable object
and computes every element in the list
one at a time as it's being queried
so for most people the list
comprehension is probably the default
choice it's used when the size of the
list is not crazy large
especially when you want to reiterate
over the list multiple times
it is faster than generator expressions
depending on the context it could be two
to three times faster
so speed is essential you want to use
these and if you need different list
methods like
especially the slicing notation you
should be using list comprehension
on the other hand you should use
generator expressions
when the range of the sequence is large
or infinite
or if you want to construct iteratable
generator objects
which are great to impress your friends
with
i should mention i'm really grateful for
the sponsors that support these videos
and the podcast
in this case eight sleep so if you enjoy
these click the links in the description
to get a discount and to support my
efforts thanks for listening
and remember try to learn something new

[05:01]
and remember try to learn something new
every day
you